<h1 id="chapter-04---커넥션-관리">Chapter 04 - 커넥션 관리</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>📌 읽으면서 밑줄친 내용 그대로 옮겨 적음. *이 붙은 문장은 생각.
</code></pre></div></div>

<ul>
  <li>TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.</li>
  <li>IP 패킷의 구성요소
    <ul>
      <li>IP 패킷 헤더(보통 20바이트)</li>
      <li>TCP 세그먼트 헤더(보통 20바이트)</li>
      <li>TCP 데이터 조각(0 혹은 그 이상의 바이트)</li>
    </ul>
  </li>
  <li>IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결된다.</li>
  <li>TCP API는 모든 세부사항을 외부로부터 숨긴다.</li>
  <li>HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.</li>
  <li>대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.</li>
  <li>DNS 이름 분석(DNS resolution) 인프라</li>
  <li>크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.</li>
  <li>인터넷 라우터는 과부하가 걸렸을 때 패킷을 마음대로 파기할 수 있다.</li>
  <li>혼잡 윈도를 연다(opening the congestion window)</li>
  <li>각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하기 때문에, TCP가 작은 크기의 데이터를 포함한 많은 수의 패킷을 전송한다면 네트워크 성능은 크게 떨어진다.</li>
  <li>TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역(control block)에 기록해 놓는다. 이 정보는 같지 않게 하기 위한 것으로, 보통 세그먼트의 최대 생명주기에 두 배 정도('2MSL'이라고 불리며 보통 2분 정도)의 시간 동안만 유지된다.</li>
  <li>Connection 헤더에는 다음 세 가지 종류의 토큰이 전달될 수 있다.
    <ul>
      <li>HTTP 헤더 필드 명은, 이 커넥션에만 해당되는 헤더들을 나열한다.</li>
      <li>임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미한다.</li>
      <li>close 값은, 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.</li>
    </ul>
  </li>
  <li>HTTP 커넥션의 성능 향상시킬 수 있는 최신 기술 4가지
    <ul>
      <li>병렬(parallel) 커넥션
        <ul>
          <li>여러 개의 TCP 커넥션을 통한 동시 HTTP 요청</li>
          <li>병렬 커넥션이 항상 더 빠르지는 않다: 클라이언트의 네트워크 대역폭이 좁을 때</li>
          <li>병렬 커넥션은 더 빠르게 '느껴질 수' 있다.</li>
        </ul>
      </li>
      <li>지속(persistent) 커넥션
        <ul>
          <li>커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용</li>
          <li>사이트 지역성(site locality)</li>
          <li>처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션</li>
          <li>튜닝된 커넥션을 유지한다.
            <ul>
              <li>TCP 느린 시작에서, 패킷을 수차례 성공적으로 전송한 결과로 한 번에 다수의 패킷을 전송할 수 있는 권한을 얻은 상태의 커넥션을 의미</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>파이프라인(pipelined) 커넥션
        <ul>
          <li>공유 TCP 커넥션을 통한 병렬 HTTP 요청</li>
        </ul>
      </li>
      <li>다중(multiplexed) 커넥션
        <ul>
          <li>요청과 응답들에 대한 중재(실험적인 기술)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프락시는 같은 커넥션상에서 다른 요청이 오는 경우는 예상하지 못한다.</li>
  <li>프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안 된다.
    <ul>
      <li><em>커넥션 연결은 Proxy만 알고있으면 되는건가?</em></li>
    </ul>
  </li>
  <li>HTTP/1.1 에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급한다.</li>
  <li>HTTP 메시지는 순번이 매겨져 있지 않아서 응답이 순서 없이 오면 순서에 맞게 정렬시킬 방법이 없다.</li>
  <li>한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(idempotent)하다고 한다.</li>
  <li>클라이언트는 POST와 같이 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안 된다.</li>
  <li>일반적으로 애플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다.</li>
</ul>

<h2 id="알게된-점">알게된 점</h2>

<ul>
  <li>기억 속에 파묻혀 있던 Connection 의 존재</li>
</ul>

<h2 id="관련해서-같이-이야기-나누고-싶은-점">관련해서 같이 이야기 나누고 싶은 점</h2>

<ul>
  <li>애플은 추상화를 많이 하기 때문에 제가 애플 생태계 먼저 개발을 시작했다면 Connection 이라는 개념 자체가 생소했을 것 같네요.
    <ul>
      <li>NSURLConnection → URLSession</li>
    </ul>
  </li>
  <li>자바를 처음 배울 때는 네트워크 요청을 Connection 생성해서 했던 거 같은데, 다른 언어도 이러한 방식을 사용하나요?</li>
  <li>왜 클라이언트 주소, 포트 번호, …, 이 같으면 안되는건지 이해를 못했습니다.;(</li>
  <li>keep-alive 도 이해하기가 쉽지 않네요. 설명해주실 분…</li>
</ul>
