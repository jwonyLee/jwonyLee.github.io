<h1 id="chapter-10---http20">Chapter 10 - HTTP/2.0</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>📌 읽으면서 밑줄친 내용 그대로 옮겨 적음. *이 붙은 문장은 생각.
</code></pre></div></div>

<ul>
  <li>회전 지연(latency)을 줄이기 위한 시도:
    <ul>
      <li>HTTP-NG 프로젝트</li>
      <li>WAKA 프로토콜 제안 by 로이 필딩(Roy Fielding)</li>
      <li>Microsoft S+M(Speed+Mobility) 프로토콜 개발</li>
      <li>SPDY 프로토콜 by 구글
        <ul>
          <li>헤더 압축 → 대역폭 절약</li>
          <li>하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연 줄이는 것이 가능해짐</li>
          <li>클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능</li>
          <li>HTTP/2.0 초안의 베이스</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프레임
    <ul>
      <li>HTTP/2.0 에서 모든 메시지는 프레임에 담겨 전송된다.</li>
      <li>프레임 헤더의 필드
        <ul>
          <li>R: 예약된 2비트 필드. 값의 의미가 정의되어 있지 않으며, 반드시 0이어야 한다. 받는 쪽에서는 이 값을 무시해야 한다.</li>
          <li>길이: 페이로드의 길이를 나타내는 14비트 무부호 정수(unsigned integer). 이 길이에 프레임 헤더는 포함되지 않는다.</li>
          <li>종류: 프레임의 종류.</li>
          <li>플래그: 8비트 플래그. 플래그 값의 의미는 프레임의 종류에 따라 다르다.</li>
          <li>R: 예약된 1비트 필드. 첫 번째 R과 마찬가지로 값의 의미가 정의되어 있지 않으며, 반드시 0이어야 한다. 받는 쪽에서는 이 값을 무시해야 한다.</li>
          <li>스트림 식별자: 31비트 스트림 식별자. 특별히 0은 커넥션 전체와 연관된 프레임을 의미한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.</li>
  <li>HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.</li>
  <li>스트림은 우선순위도 가질 수 있다.</li>
  <li>모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다.</li>
  <li>서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만든다. 이는 스트림을 만들 때 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨을 의미한다.</li>
  <li>HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.</li>
  <li>HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
    <ul>
      <li><strong>소켓 통신으로 스트림을 연결하고 있는 것을 대체할 수 있는가?</strong></li>
    </ul>
  </li>
  <li>HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다.</li>
</ul>

<h2 id="알게된-점">알게된 점</h2>

<ul>
  <li>HTTP/2.0 과 HTTP/1.0 의 차이점?</li>
  <li>오픈 소스 정신이라고 해야할까? … 사기업이 국제 표준에 기여하는 부분은 여전히 신기하다.</li>
</ul>

<h2 id="관련해서-같이-이야기-나누고-싶은-점">관련해서 같이 이야기 나누고 싶은 점</h2>

<ul>
  <li>크롬 106 부터 서버 푸시 기능은 비활성화 되었다고 합니다: <a href="https://developer.chrome.com/blog/removing-push/">참고</a>
    <ul>
      <li>HTTP/2.0 을 사용하는 사이트의 1.25% 만이 이 기능을 사용함</li>
      <li>https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/</li>
    </ul>
  </li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li>https://developer.chrome.com/blog/removing-push/</li>
</ul>
