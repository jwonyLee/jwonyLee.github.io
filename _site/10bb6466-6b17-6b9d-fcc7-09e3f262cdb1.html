<blockquote>
  <p><strong>Note</strong>
ReactorKit 공식문서를 참고하여 정리한 글입니다.</p>
</blockquote>

<h2 id="reactorkit">ReactorKit</h2>

<ul>
  <li>반응형 + 단방향 스위프트 어플리케이션 아키텍처 프레임워크</li>
  <li>Flux + Reactive Programming</li>
</ul>

<h2 id="view">View</h2>

<ul>
  <li>ViewController, Cell 은 View 로 취급한다.</li>
  <li>View 는 오로지 action stream 과 state stream 을 매핑하는 방법을 정의한다.</li>
  <li>기존 객체에 <code class="language-plaintext highlighter-rouge">View</code> 프로토콜을 채택한다. 그러면 자동으로 <code class="language-plaintext highlighter-rouge">reactor</code> 라는 이름의 프로퍼티를 갖게 된다. 이 프로퍼티는 외부에서 주입한다.</li>
  <li><code class="language-plaintext highlighter-rouge">reactor</code> 프로퍼티가 변경될 때, <code class="language-plaintext highlighter-rouge">bind(reactor:)</code> 메서드가 호출된다. action stream 과 state stream 을 바인딩하려면 이 메서드를 구현한다.</li>
  <li>Storyboard 를 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">StoryboardView</code> 프로퍼티를 채택한다. <code class="language-plaintext highlighter-rouge">View</code> 프로퍼티와 모든 것이 동일하지만, 한 가지 다른 점은 <code class="language-plaintext highlighter-rouge">StroyboardView</code> 는 뷰가 로드 된 후(viewDidLoad)에 바인딩을 한다.</li>
</ul>

<h2 id="reactor">Reactor</h2>

<ul>
  <li>뷰의 상태를 관리하는 UI와 독립적인 레이어다.</li>
  <li>reactor 의 가장 중요한 것은 뷰의 제어 흐름(control flow)을 분리하는 것이다.</li>
  <li>모든 뷰는 그에 상응하는 reactor 를 가지고 있으며, 모든 로직을 reactor 에 위임한다.</li>
  <li>reactor 는 view 에 의존성을 갖고 있지 않기 때문에 테스트가 쉽다.</li>
  <li>reactor 를 정의하려면 <code class="language-plaintext highlighter-rouge">Reactor</code> 프로토콜을 채택한다. 이 프로토콜은 세 개의 타입 정의를 요구한다. 또한 <code class="language-plaintext highlighter-rouge">initialState</code> 라는 프로퍼티를 요구한다.
    <ul>
      <li>Action: 사용자의 상호 작용을 나타낸다.</li>
      <li>Mutation: Action 과 State 사이의 중간 역할을 한다.</li>
      <li>State: 뷰의 상태를 나타낸다.</li>
    </ul>
  </li>
  <li>reactor 는 두 개의 단계로 action stream 을 state stream 로 변환한다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mutate()</code>, <code class="language-plaintext highlighter-rouge">reduce()</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">mutate()</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mutate()</code> 는 Action 을 받아서 <code class="language-plaintext highlighter-rouge">Observable&lt;Mutation&gt;</code>으로 만든다.</li>
      <li><code class="language-plaintext highlighter-rouge">func mutate(action: Action) -&gt; Observable&lt;Mutation&gt;</code>
        <ul>
          <li>비동기 operation 혹은 API 콜과 같은 모든 사이드 이펙트는 이 메서드에서 실행된다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">mutate</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">Action</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Mutation</span><span class="o">&gt;</span> <span class="p">{</span>
  	<span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
  		<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">refreshFollowingStatus</span><span class="p">(</span><span class="n">userID</span><span class="p">):</span> <span class="c1">// receive an action</span>
  			<span class="k">return</span> <span class="kt">UserAPI</span><span class="o">.</span><span class="nf">isFollowing</span><span class="p">(</span><span class="n">userID</span><span class="p">)</span> <span class="c1">// create an API stream</span>
  			<span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">(</span><span class="nv">isFollowing</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Mutation</span> <span class="k">in</span>
  				<span class="k">return</span> <span class="kt">Mutation</span><span class="o">.</span><span class="nf">setFollowing</span><span class="p">(</span><span class="n">isFollowing</span><span class="p">)</span> <span class="c1">// convert to Mutation stream</span>
  			<span class="p">}</span>
  		<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">follow</span><span class="p">(</span><span class="n">userID</span><span class="p">):</span>
  			<span class="k">return</span> <span class="kt">UserAPI</span><span class="o">.</span><span class="nf">follow</span><span class="p">()</span>
  			<span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kt">Mutation</span> <span class="k">in</span>
  				<span class="k">return</span> <span class="kt">Mutation</span><span class="o">.</span><span class="nf">setFollowing</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
  			<span class="p">}</span>
  	<span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">reduce()</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">reduce()</code>는 이전의 <code class="language-plaintext highlighter-rouge">State</code>와 <code class="language-plaintext highlighter-rouge">Mutation</code>으로부터 새로운 <code class="language-plaintext highlighter-rouge">State</code>를 만든다.</li>
      <li><code class="language-plaintext highlighter-rouge">func reduce(state: State, mutation: Mutation) -&gt; State</code>
        <ul>
          <li>이 메서드는 순수 함수이다. 오로지 동기적으로 새로운 <code class="language-plaintext highlighter-rouge">State</code>를 반환해야 한다. 이 메서드에서 어떠한 사이드 이펙트도 만들면 안된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">transform()</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">transform()</code> 는 스트림을 각각 변환시킨다. 세 개의 <code class="language-plaintext highlighter-rouge">transform()</code> 메서드가 있다.</li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">transform</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Action</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Action</span><span class="o">&gt;</span>
  <span class="kd">func</span> <span class="nf">transform</span><span class="p">(</span><span class="nv">mutation</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Mutation</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Mutation</span><span class="o">&gt;</span>
  <span class="kd">func</span> <span class="nf">transform</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">State</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">State</span><span class="o">&gt;</span>
</code></pre></div>    </div>

    <ul>
      <li>이러한 메서드를 구현하여 다른 관찰 가능한 스트림과 변환하고 결합하라. 예를 들어, <code class="language-plaintext highlighter-rouge">transform(mutation:)</code> 는 전역 이벤트 스트림(global event stream)을 mutation stream 과 조합하기에 좋은 장소이다. Global States 섹션에서 더 자세한 것을 살펴볼 수 있다.</li>
      <li>디버깅을 목적으로 사용할 수도 있다.</li>
    </ul>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">transform</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Action</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Action</span><span class="o">&gt;</span> <span class="p">{</span>
  	<span class="k">return</span> <span class="n">action</span><span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"action"</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="advanced">Advanced</h2>

<h3 id="global-states">Global States</h3>

<p>Redux와 달리, ReactorKit 은 앱의 전역 상태를 제공하지 않는다. 이것이 의미하는 바는 전역 상태를 관리하기 위해 무엇이든 사용할 수 있다는 것이다. <code class="language-plaintext highlighter-rouge">BehaviorSubject</code>, <code class="language-plaintext highlighter-rouge">PublishSubject</code> 혹은 reactor 조차 사용할 수 있다. ReactorKit 은 global state 를 가지는 것을 강제하지 않는다. 그래서 애플리케이션의 특정 기능에 ReactorKit 을 사용할 수 있다.</p>

<p><strong>Action -&gt; Mutation -&gt; State</strong> 흐름에는 global state 가 없다. <code class="language-plaintext highlighter-rouge">transform(mutation:)</code> 을 사용해서 global state 를 mutation 으로 변환할 수 있다. 현재 인증된 사용자를 저장하는 global <code class="language-plaintext highlighter-rouge">BehaviorSubject</code> 를 가진다고 가정해보자. <code class="language-plaintext highlighter-rouge">Mutation.setUser(User?)</code> 를 방출하고 싶다면, <code class="language-plaintext highlighter-rouge">currentUser</code> 가 변경될 때, 다음과 같이 할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">currentUser</span><span class="p">:</span> <span class="kt">BehaviorSubject</span><span class="o">&lt;</span><span class="kt">User</span><span class="o">&gt;</span> <span class="c1">// global state</span>

<span class="kd">func</span> <span class="nf">transform</span><span class="p">(</span><span class="nv">mutation</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">Mustation</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Observavle</span><span class="o">&lt;</span><span class="kt">Mustation</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">Observable</span><span class="o">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">mutation</span><span class="p">,</span> <span class="n">currentUser</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Mutation</span><span class="o">.</span><span class="n">setUser</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그런 다음 view가 reactor에 action을 보내고 <code class="language-plaintext highlighter-rouge">currentUser</code> 가 변경될 때마다 mutation이 방출된다.</p>

<h3 id="view-communication">View Communication</h3>

<p>여러 뷰 사이의 통신을 하기 위해 callback closure 혹은 delegate 패턴에 익숙해져야 한다. 이를 위해 Reacotkit 은 reactive extensions 사용을 추천한다. 일반적으로 가장 자주 사용되는 <code class="language-plaintext highlighter-rouge">Control Event</code>의 <code class="language-plaintext highlighter-rouge">UIButton.rx.tap</code> 이 있다. 핵심 개념은 커스텀 뷰를 UIButton 이나 UILabel 처럼 다루는 것이다.</p>

<p>메세지를 보여주는 <code class="language-plaintext highlighter-rouge">ChatViewController</code> 를 가지고 있다고 가정해보자. <code class="language-plaintext highlighter-rouge">ChatViewController</code>는 <code class="language-plaintext highlighter-rouge">MessageInputView</code> 를 소유하고 있다. 사용자가 <code class="language-plaintext highlighter-rouge">MessageInputView</code>에 있는 보내기 버튼을 탭했을 때, 텍스트는 <code class="language-plaintext highlighter-rouge">ChatViewController</code> 에 보내져야 한다. 그리고 <code class="language-plaintext highlighter-rouge">ChatViewController</code> 는 이를 reactor의 액션과 묶어야 한다. (bind)</p>

<p>아래는 <code class="language-plaintext highlighter-rouge">MessageInputView</code> 의 reative extension 을 활용한 예시이다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Reactive</span> <span class="k">where</span> <span class="kt">Base</span><span class="p">:</span> <span class="kt">MessageInputView</span> <span class="p">{</span>
	<span class="k">var</span> <span class="nv">sendButtonTap</span><span class="p">:</span> <span class="kt">ControlEvent</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="k">let</span> <span class="nv">source</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">sendButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span><span class="o">.</span><span class="nf">withLatestFrom</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
		<span class="k">return</span> <span class="kt">ControlEvent</span><span class="p">(</span><span class="nv">events</span><span class="p">:</span> <span class="n">source</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 익스텐션을 <code class="language-plaintext highlighter-rouge">ChatVeiwController</code>에서 사용할 수 있다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Reactive</span> <span class="k">where</span> <span class="kt">Base</span><span class="p">:</span> <span class="kt">MessageInputView</span> <span class="p">{</span>
	<span class="k">var</span> <span class="nv">sendButtonTap</span><span class="p">:</span> <span class="kt">ControlEvent</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="k">let</span> <span class="nv">source</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">sendButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">tap</span><span class="o">.</span><span class="nf">withLatestFrom</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
		<span class="k">return</span> <span class="kt">ControlEvent</span><span class="p">(</span><span class="nv">events</span><span class="p">:</span> <span class="n">source</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="testing">Testing</h3>

<p>ReactiorKit 은 테스트를 위한 기능이 내장되어 있다.</p>

<p><strong>What to test (무엇을 테스트?)</strong></p>

<p>우선 무엇을 테스트할 지 결정해야 한다. 두 개의 테스트가 있다: view 와 reactor</p>

<ul>
  <li>View
    <ul>
      <li>Action: 주어진 사용자 상호작용이 reactor에게 적절히 보내졌는가?</li>
      <li>State: 뷰의 속성이 state 에 맞게 제대로 설정되었는가?</li>
    </ul>
  </li>
  <li>Reactor
    <ul>
      <li>State: state가 action에 맞춰 적절히 변경되었는가?</li>
    </ul>
  </li>
</ul>

<p><strong>View testing</strong></p>

<p>뷰는 stub reactor 에서 테스트 할 수 있다. reactor는 <code class="language-plaintext highlighter-rouge">stub</code> 이라는 actions 를 기록하고, state를 강제로 변경하는 프로퍼티를 가진다. reactor의 stub 을 활성화 하면, <code class="language-plaintext highlighter-rouge">mutate()</code> 와 <code class="language-plaintext highlighter-rouge">reduce()</code> 둘 다 실행되지 않는다. stub은 다음과 같은 프로퍼티들을 가진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">StateRelay</span><span class="o">&lt;</span><span class="kt">Reactor</span><span class="o">.</span><span class="kt">State</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="k">var</span> <span class="nv">action</span><span class="p">:</span> <span class="kt">ActionSubject</span><span class="o">&lt;</span><span class="kt">Reactor</span><span class="o">.</span><span class="kt">Action</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="k">var</span> <span class="nv">actions</span><span class="p">:</span> <span class="p">[</span><span class="kt">Reactor</span><span class="o">.</span><span class="kt">Action</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span> <span class="c1">// recorded actions</span>
</code></pre></div></div>

<p>테스트 케이스 예제가 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">testAction_refresh</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1. stub reactor 를 준비한다.</span>
	<span class="k">let</span> <span class="nv">reactor</span> <span class="o">=</span> <span class="kt">MyReactor</span><span class="p">()</span>
	<span class="n">reactor</span><span class="o">.</span><span class="n">isStubEnabled</span> <span class="o">=</span> <span class="kc">true</span>

	<span class="c1">// 2. strub reactor 와 함께 view 를 준비한다.</span>
	<span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">MyView</span><span class="p">()</span>
	<span class="n">view</span><span class="o">.</span><span class="n">reactor</span> <span class="o">=</span> <span class="n">reactor</span>
	
	<span class="c1">// 3. 사용자 상호 작용을 보낸다.</span>
	<span class="n">view</span><span class="o">.</span><span class="n">refreshControl</span><span class="o">.</span><span class="nf">sendActions</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">valueChanged</span><span class="p">)</span>
	
	<span class="c1">// 4. actions 를 검증한다.</span>
	<span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">reactor</span><span class="o">.</span><span class="n">stub</span><span class="o">.</span><span class="n">actions</span><span class="o">.</span><span class="n">last</span><span class="p">,</span> <span class="o">.</span><span class="n">refresh</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testState_isLoading</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1. stub reactor 를 준비한다.</span>
	<span class="k">let</span> <span class="nv">reactor</span> <span class="o">=</span> <span class="kt">MyReactor</span><span class="p">()</span>
	<span class="n">reactor</span><span class="o">.</span><span class="n">isStubEnabled</span> <span class="o">=</span> <span class="kc">true</span>
	
	<span class="c1">// 2. strub reactor 와 함께 view 를 준비한다.</span>
	<span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">MyView</span><span class="p">()</span>
	<span class="n">view</span><span class="o">.</span><span class="n">reactor</span> <span class="o">=</span> <span class="n">reactor</span>
	
	<span class="c1">// 3. stub 의 상태를 설정한다.</span>
	<span class="n">reactor</span><span class="o">.</span><span class="n">stub</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kt">MyReactor</span><span class="o">.</span><span class="kt">State</span><span class="p">(</span><span class="nv">isLoading</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
	
	<span class="c1">// 4. view 의 속성을 검증한다.</span>
	<span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="n">isAnimating</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Reactor testing</strong></p>

<p>reactor 의 테스트는 독립적이다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">testIsBookmarked</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="nv">reactor</span> <span class="o">=</span> <span class="kt">MyReactor</span><span class="p">()</span>

	<span class="n">reactor</span><span class="o">.</span><span class="n">action</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="o">.</span><span class="n">toggleBookmarked</span><span class="p">)</span>
	<span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">reactor</span><span class="o">.</span><span class="n">currentState</span><span class="o">.</span><span class="n">isBookmarked</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

	<span class="n">reactor</span><span class="o">.</span><span class="n">action</span><span class="o">.</span><span class="nf">onNext</span><span class="p">(</span><span class="o">.</span><span class="n">toggleBookmarked</span><span class="p">)</span>
	<span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">reactor</span><span class="o">.</span><span class="n">currentState</span><span class="o">.</span><span class="n">isBookmarked</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div></div>

<p>때때로 상태는 한 번의 action 을 위해 한 번보다 많이 변한다. 예를 들어, <code class="language-plaintext highlighter-rouge">.refresh</code> action은 처음에 <code class="language-plaintext highlighter-rouge">state.isLoading</code>을 <code class="language-plaintext highlighter-rouge">true</code>로 설정하고, 새로고침 후에 <code class="language-plaintext highlighter-rouge">false</code>로 설정한다. 이 경우에 있어서 <code class="language-plaintext highlighter-rouge">state.isLoading</code>과 <code class="language-plaintext highlighter-rouge">currentState</code> 는 테스트하기 어렵다. 그래서 아마 <code class="language-plaintext highlighter-rouge">RxTest</code> 또는 <code class="language-plaintext highlighter-rouge">RxExpect</code>가 필요하다. 여기 <code class="language-plaintext highlighter-rouge">RxSwift</code> 를 이용한 테스트 케이스 예시가 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">testIsLoading</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// given</span>
	<span class="k">let</span> <span class="nv">scheduler</span> <span class="o">=</span> <span class="kt">TestScheduler</span><span class="p">(</span><span class="nv">initialClock</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">let</span> <span class="nv">reactor</span> <span class="o">=</span> <span class="kt">MyReactor</span><span class="p">()</span>
	<span class="k">let</span> <span class="nv">disposeBag</span> <span class="o">=</span> <span class="kt">DisposeBag</span><span class="p">()</span>
	
	<span class="c1">// when</span>
	<span class="n">scheduler</span>
		<span class="o">.</span><span class="nf">createHotObservable</span><span class="p">([</span>
		<span class="o">.</span><span class="nf">next</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="o">.</span><span class="n">refresh</span><span class="p">)</span> <span class="c1">// send .refresh at 100 scheduler time</span>
		<span class="p">])</span>
		<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="n">reactor</span><span class="o">.</span><span class="n">action</span><span class="p">)</span>
		<span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
		
	<span class="c1">// then</span>
	<span class="k">let</span> <span class="nv">response</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">.</span><span class="nf">start</span><span class="p">(</span><span class="nv">created</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">subscribed</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">disposed</span><span class="p">:</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reactor</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="nf">map</span><span class="p">(\</span><span class="o">.</span><span class="n">isLoading</span><span class="p">)</span>
	<span class="p">}</span>
	
	<span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="nf">map</span><span class="p">(\</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">element</span><span class="p">),</span> <span class="p">[</span>
		<span class="kc">false</span><span class="p">,</span> <span class="c1">// initial state</span>
		<span class="kc">true</span><span class="p">,</span>  <span class="c1">// just after .refresh</span>
		<span class="kc">false</span>  <span class="c1">// after refreshing</span>
	<span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scheduling">Scheduling</h3>

<p><code class="language-plaintext highlighter-rouge">scheduler</code> 프로퍼티를 정의한다.</p>

<p>state stream을 줄이고 관찰하는 데 사용되는 스케줄러를 지정하기 위해 scheduler 프로퍼티를 정의하라. 이 queue는 serial queue이어야 한다. 기본 스케줄러는 <code class="language-plaintext highlighter-rouge">CurrentThreadScheduler</code> 이다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">MyReactor</span><span class="p">:</span> <span class="kt">Reactor</span> <span class="p">{</span>
	<span class="k">let</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="kt">Scheduler</span> <span class="o">=</span> <span class="kt">SerialDispatchQueueScheduler</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="k">default</span><span class="p">)</span>
	
	<span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">mutation</span><span class="p">:</span> <span class="kt">Mutation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>
		<span class="c1">// executed in a background thread</span>
		<span class="nf">heavyAndImportantCalculation</span><span class="p">()</span>
		<span class="k">return</span> <span class="n">state</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pulse">Pulse</h3>

<p><code class="language-plaintext highlighter-rouge">Pulse</code>는 변화가 있을 때만 차이가 있다. 아래 예시로 살펴보자.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">messagePulse</span><span class="p">:</span> <span class="kt">Pulse</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Pulse</span><span class="p">(</span><span class="nv">wrappedValue</span><span class="p">:</span> <span class="s">"Hello tokijh"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">oldMessagePulse</span><span class="p">:</span> <span class="kt">Pulse</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">messagePulse</span>
<span class="n">messagePulse</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">"Hello tokijh"</span> <span class="c1">// add valueUpdatedCount +1</span>
<span class="n">oldMessagePulse</span><span class="o">.</span><span class="n">valueUpdatedCount</span> <span class="o">!=</span> <span class="n">messagePulse</span><span class="o">.</span><span class="n">valueUpdatedCount</span> <span class="c1">// true</span>
<span class="n">oldMessagePulse</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">messagePulse</span><span class="o">.</span><span class="n">value</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>동일한 값인 경우에도 새 값이 할당된 경우에만 이벤트를 수신할 때 사용한다. 경고 메시지를 띄우는 경우를 예로 들 수 있다. 이러한 경우를 위해 Pulse 를 사용하면, 값이 중복되어 들어오더라도(연속적으로 똑같은 에러 메시지를 표시애햐 할 때) 사용자에게 경고 메시지를 보여줄 수 있다.</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://github.com/ReactorKit/ReactorKit">ReactorKit/ReactorKit: A library for reactive and unidirectional Swift applications</a></li>
</ul>

<h2 id="태그">태그</h2>

<p>#iOS/Framework/ReactorKit #iOS/Architecture</p>
