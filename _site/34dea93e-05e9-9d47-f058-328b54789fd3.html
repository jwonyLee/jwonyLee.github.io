<!DOCTYPE html>
<html>
    <script type="application/json" id="pagePermalinks">
    {
        
        "제목이-test-입니다": "/wiki/test/", 
        
        "optional-이란-무엇인지-설명하시오": "/7972af36-2e95-e5a9-936b-b2d8008d0dd2", 
        
        "tableview-reloadsections": "/6818f72c-8679-19ea-5849-0fa044b8e138", 
        
        "tableview-focus": "/9725d37e-e0e5-a1ed-f4fc-97a20479f6c8", 
        
        "mvc": "/048e70ef-9d22-1bdd-7eaf-6ff020589788", 
        
        "delegate": "/acb464ba-05ef-d1f8-d186-8452b3c43600", 
        
        "delegates-notification": "/9ba05cc2-3d59-2b87-ea58-f3e733d6be01", 
        
        "fast-enumeration": "/9740e81d-a83f-61b9-05b2-bbae589cb348", 
        
        "kvo": "/41c517d9-8d30-b798-dc70-778ecc8eeba4", 
        
        "swift-멀티-쓰레드로-동작하는-앱을-작성하고-싶을-때-고려할-수-있는-방식들을-설명하시오": "/1ed82824-eb50-f1aa-3b78-7d9d67ca19f5", 
        
        "protocol": "/6f275a5a-09f0-5f53-7915-468b140ff59a", 
        
        "singleton": "/7a278d9b-ab71-5000-e7a8-be05b116af61", 
        
        "struct": "/2c42b7f6-d4e0-db2b-d0b7-4bdd7d750dfb", 
        
        "instance-method-class-method": "/5c700d5d-fd29-8292-6da1-c293485aabc2", 
        
        "swift-hashable이-무엇이고-equatable을-왜-상속해야-하는지-설명하시오": "/cc011585-af44-56be-eb26-97493639019e", 
        
        "swift-탈출-클로저에-대하여-설명하시오": "/110c7a71-3d8e-f97e-14d9-24d6c28778f1", 
        
        "swift-extension에-대해-설명하시오": "/1b55afe8-60cf-8c94-0be0-14f2859f9e38", 
        
        "swift-접근-제어자의-종류엔-어떤게-있는지-설명하시오": "/4a1becfc-9139-fbe2-ee07-67ed68e3de10", 
        
        "swift-defer가-호출되는-순서는-어떻게-되고-defer가-호출되지-않는-경우를-설명하시오": "/f1365c28-8c8e-c33f-4627-b94b76d3985d", 
        
        "swift-defer란-무엇인지-설명하시오": "/d84661f1-c2b9-4d73-7977-f5678f0c90b1", 
        
        "ios-bounds-와-frame-의-차이점을-설명하시오": "/221ef090-7f3a-cb99-5502-01ff6d90e6a6", 
        
        "ios-실제-디바이스가-없을-경우-개발-환경에서-할-수-있는-것과-없는-것을-설명하시오": "/8dd56bf5-45ae-9862-dc40-fdc26b6c8e2b", 
        
        "ios-앱이-foreground에-있을-때와-background에-있을-때-어떤-제약사항이-있나요": "/2163eba4-0877-e153-25c7-2ea70a310db8", 
        
        "ios-상태-변화에-따라-다른-동작을-처리하기-위한-앱델리게이트-메서드들을-설명하시오": "/d30afc77-e653-1750-2441-cb8efaf43483", 
        
        "ios-nsoperationqueue-와-gcd-queue-의-차이점을-설명하시오": "/7a5cb9b6-0365-2deb-31ac-8867bdb3184a", 
        
        "ios-gcd-api-동작-방식과-필요성에-대해-설명하시오": "/ad09382f-5f7c-c0d8-7b8a-67428b4dbd0b", 
        
        "ios-토이-프로젝트-하면서-알게된-점": "/68384391-8118-fa64-f551-b01da879d361", 
        
        "ios-foundation-kit은-무엇이고-포함되어-있는-클래스들은-어떤-것이-있는지-설명하시오": "/25571d26-a348-8ff2-6398-a899add33df3", 
        
        "ios-notificationcenter-동작-방식과-활용-방안에-대해-설명하시오": "/7770f268-14af-f587-7771-54a2bb9a57b4", 
        
        "ios-하나의-view-controller-코드에서-여러-tableview-controller-역할을-해야-할-경우-어떻게-구분해서-구현해야-하는지-설명하시오": "/ba700875-ce39-9567-5a76-b69390ff8828", 
        
        "ios-app-bundle의-구조와-역할에-대해-설명하시오": "/35d80db8-e942-f7d2-f087-31cd5bde82ba", 
        
        "ios-view-객체에-대해-설명하시오": "/b67ff6f6-143a-2760-26a4-81efbd235844", 
        
        "ios-uiview-에서-layer-객체는-무엇이고-어떤-역할을-담당하는지-설명하시오": "/1cae6cc6-f26e-8a4a-f9c6-a6f0e1ad5277", 
        
        "ios-앱이-시작할-때-main-c-에-있는-uiapplicationmain-함수에-의해서-생성되는-객체는-무엇인가": "/7e14cff5-8a2d-81a5-05f7-de775ca4ad96", 
        
        "ios-모든-view-controller-객체의-상위-클래스는-무엇이고-그-역할은-무엇인가": "/b5bbb478-501f-7d48-0876-a8a3c779bbc5", 
        
        "ios-앱의-콘텐츠나-데이터-자체를-저장-보관하는-특별한-객체를-무엇이라고-하는가": "/4880a67e-ed38-69de-b858-ce92985e8df0", 
        
        "ios-앱-화면의-콘텐츠를-표시하는-로직과-관리를-담당하는-객체를-무엇이라고-하는가": "/6f6c96ec-db60-3f68-0158-dca30f046316", 
        
        "ios-swift의-클로저와-objective-c의-블록은-어떤-차이가-있는가": "/486edc27-d3f9-bed4-099e-f5983ff97baa", 
        
        "ios-스토리보드를-이용했을때의-장단점을-설명하시오": "/c5dfccf5-2b57-6f88-4b0b-c6b25bd2a68d", 
        
        "ios-app-thinning에-대해서-설명하시오": "/aa6857a4-84f0-a3e2-a738-64d58b0cd9c5", 
        
        "ios-global-dispatchqueue-의-qos-에는-어떤-종류가-있는지-각각-어떤-의미인지-설명하시오": "/cd5e1f4f-8164-94cf-a774-bbc775a38cd7", 
        
        "ios-hugging-resistance에-대해서-설명하시오": "/1aa547a5-41c4-8dd1-b435-17560674ca3a", 
        
        "ios-understanding-auto-layout": "/1ef8e42c-7d55-bc67-cbce-85cd58b7a910", 
        
        "ios-left-constraint-와-leading-constraint-의-차이점을-설명하시오": "/1cf039e2-3425-0ddb-02e8-a054c8a9f7b9", 
        
        "ios-arc란-무엇인지-설명하시오": "/b7fdc0a7-7a2a-81cf-ce06-b66f06945afb", 
        
        "ios-anatomy-of-a-constraint": "/91779299-b1d8-f752-efbb-bebf18b9b997", 
        
        "swift-strong-과-weak-참조-방식에-대해-설명하시오": "/7c62d9b2-06d5-65d7-6898-1046353eebd0", 
        
        "ios-contacts-프레임워크-톺아보기": "/8b0a4b90-250f-9ea1-905c-c5c6ffd0f9cc", 
        
        "objective-c-arc-대신-manual-reference-count-방식으로-구현할-때-꼭-사용해야-하는-메서드들을-쓰고-역할을-설명하시오": "/cddfe26b-169d-567a-5382-8ae53ec547e2", 
        
        "objective-c-retain-과-assign-의-차이점을-설명하시오": "/22f59356-46ea-4d5a-030f-e9a600736722", 
        
        "swift-강한-순환-참조-strong-reference-cycle-는-어떤-경우에-발생하는지-설명하시오": "/0e5f64f9-ad6d-a804-3131-2c3b871c78f1", 
        
        "objective-c-autorelease-pool을-사용해야-하는-상황을-두-가지-이상-예로-들어-설명하시오": "/f61fef68-7386-ba55-b341-d15ea08393d4", 
        
        "objective-c-특정-객체를-autorelease-하기-위해-필요한-사항과-과정을-설명하시오": "/8c462797-aaee-445d-efdc-b532b964984f", 
        
        "swift-mutating-키워드에-대해-설명하시오": "/844246b6-6f5f-10ac-344c-ad6a72e16681", 
        
        "ios-앱이-in-active-상태가-되는-시나리오를-설명하시오": "/ebf8366a-b1c6-8312-3390-591d37f51f88", 
        
        "ios-scene-delegate에-대해-설명하시오": "/1da5c7c4-77b5-078d-7d51-cb4af2a594be", 
        
        "swift-delegate란-무언인가-설명하고-retain-되는지-안되는지-그-이유를-함께-설명하시오": "/b859a722-c185-18ca-40e3-ff2874327645", 
        
        "ios-uikit-클래스들을-다룰-때-꼭-처리해야하는-애플리케이션-쓰레드-이름은-무엇인가": "/3298b635-b078-7690-5cf0-2c5ad08df3f1", 
        
        "ios-오토레이아웃을-코드로-작성하는-방법은-무엇인가-3가지": "/31b7b10d-02ae-8cf6-064d-5bfb2cc11000", 
        
        "ios-오토-레이아웃-기반-뷰에-cornerradius-적용하기": "/a3a7ad89-8247-c3be-a830-793149274df0", 
        
        "ios-코드로-버튼에-이미지와-텍스트-넣기": "/a1e1ff84-afb9-3cd4-779b-ffac01f78ed8", 
        
        "ios-uiview-cliptobounds와-layer-maskstobounds": "/10a55411-2e65-1d24-1465-93b6a7ef8317", 
        
        "ios-컬렉션뷰-최상단으로-이동하기": "/794a8fe6-1bd9-f907-b97f-5c8d58f174c9", 
        
        "ios-커스텀-셀-적용하기": "/e6ad015d-77c7-a653-dd35-5830c489dcd0", 
        
        "layoutmarginguide-safelayoutguide": "/0f24fcbb-ce52-e617-1f35-7592cc832513", 
        
        "ios-네비게이션-타이틀-변경": "/a0ff24e0-518a-643b-b9e1-4d0f26ae6faa", 
        
        "ios-뷰의-그림자-만들기": "/8f337062-db00-d89b-5151-0e2eec7ebf30", 
        
        "ios-스토리보드없이-코드로-개발하기": "/8e6f8bf9-13fb-aef8-f6d5-701c02bc7ec2", 
        
        "swift-긍정적인-guard-사용": "/21b56994-cc18-9f41-e982-cf9735b9d345", 
        
        "rxswift-학습-정리": "/116c4063-ed05-65d1-2e79-b2024a9706cb", 
        
        "rxswift-completable": "/fc8764e8-1faa-3b9c-2220-92d0898700d0", 
        
        "rxswift-maybe": "/438a434c-e450-d3d8-a28c-3dbf1aed01f3", 
        
        "rxswift-single": "/22b54afe-9f09-0d87-860f-a50de5b642ae", 
        
        "rxswift-uitextfield-text의-변경을-감지하지-못할-때": "/71f3e025-53b0-9a83-78df-fbf9c5bba6f6", 
        
        "ios-wwdc2021-meet-async-await-in-swift": "/d749ec3d-86c8-8b21-144b-74fa7b69819a", 
        
        "ios-uimenu-사용해보기": "/175c0e8e-dcc4-2838-4b58-30c0ac22f9e4", 
        
        "ios-오디오-녹음-재생-저장하기": "/b3ea49d4-8f7a-b9e0-2427-fd3b1e243fd8", 
        
        "ios-userdefaults-keychain-core-data": "/3efa3d59-c701-1158-7923-59270f51357b", 
        
        "ios-uistackview": "/5b441ad2-f77c-e2c0-5787-e4ed4138ec3c", 
        
        "book-리눅스-입문자를-위한-명령어-사전": "/bc24663e-8037-285f-8159-94f8b91384e1", 
        
        "shell-script-터미널에서-명령어로-마크다운-파일-만들기": "/1114d9a9-1eb1-1bf3-4819-6612d416beda", 
        
        "design-pattern-repository-패턴": "/e41ac27e-0ce9-c443-2af4-7ceef30ec815", 
        
        "rxswift-rxswiftext-일부-연산자-정리": "/847e6d25-0406-9f55-65ea-71fe4ead4c2f", 
        
        "book-처음-배우는-플라스크-웹-프로그래밍": "/a2ed4fc7-e0f5-7e9d-802f-0ef7e6a021d5", 
        
        "wwdc2019-making-apps-with-core-data": "/0ce0a0ce-7b54-a57c-bd4d-8ccad29cc898", 
        
        "book-함께-자라기": "/7900102b-dad3-42b6-e1ff-bf18525660b2", 
        
        "xctest-비동기-메서드-테스트하기": "/ad1f874e-3ce1-2b9e-9b8e-bd8121e49b50", 
        
        "book-제대로-배우는-수학적-최적화": "/65ef6f13-238e-376b-c5d8-423601f482a5", 
        
        "ios-컬렉션뷰에-뱃지-추가하기": "/354752f2-0c01-5d34-7214-bacd077e4153", 
        
        "ios-사진-촬영-기능-구현하기": "/ad896c4a-9cb1-57eb-6f2d-ed0f91110a7f", 
        
        "ios-커스텀-폰트-적용하기-with-dynamic-type": "/087cf713-71b1-fed1-92de-eb4eb894c0d4", 
        
        "ios-원하는-위치의-셀로-이동": "/af9b3263-31b2-74e1-2656-1c20982834e6", 
        
        "swift-중첩-클로저의-캡처-리스트": "/6e52590c-ff19-5ed6-6c98-ea043d0ef93a", 
        
        "xcode-시뮬레이터가-표시되지-않을-때": "/5a1edbef-5c3a-9582-4689-be1c9860dc57", 
        
        "rxswift-throttle-debounce": "/255d538c-8044-4bbd-05a9-c125b5d505ee", 
        
        "포스트의-생성-시간-마지막-수정-시간-구하기": "/7de6818f-99cb-bdf9-8bb2-92c51770076e", 
        
        "ios-moya-사용법": "/1ff142a9-0d9f-cb69-7893-6ed85e7501cc", 
        
        "book-동시성-프로그래밍": "/565ee835-604a-3913-13cd-7dd4e83143ef", 
        
        "swift-writing-high-performance-swift-code": "/34dea93e-05e9-9d47-f058-328b54789fd3", 
        
        "ios-swift-package-만들기": "/b6e7d281-7f11-d868-7945-9704afcaccaa", 
        
        "회사-프로젝트에-swiftgen-도입기": "/3acba79d-c253-a833-0fb8-9534af3cdffc", 
        
        "book-기업의-성공을-이끄는-developer-relations": "/f61f3b71-2fcb-fb9c-5bf6-8695576b8ada", 
        
        "회사-프로젝트에-swiftlint-도입기": "/98e2a8e5-c76c-0e4c-0d1c-d9c4ae71426c", 
        
        "ios-reactorkit": "/10bb6466-6b17-6b9d-fcc7-09e3f262cdb1", 
        
        "ios-live-activity": "/dda861ad-c5d0-9e0b-e516-e0ea209f7761", 
        
        "피-땀-리셋": "/765e8330-4b2a-eaae-e63c-53809a9db388", 
        
        "ios-dateformatter-는-비싸다": "/e8ed064c-4163-90c1-170a-a1d09ecb6748", 
        
        "book-적정-소프트웨어-아키텍처": "/14542ed1-ffb9-c062-5b3a-828755257d2b", 
        
        "한-컴퓨터에-github-계정-여러개-쓰기": "/0356f2ee-7e47-af38-047f-c9f13e392d73", 
        
        "02장-url과-리소스": "/720b3660-1039-0fc7-54a4-48facfcfda5c", 
        
        "03장-http-메시지": "/2715b8ab-d021-6bef-7140-3387cd6c23fc", 
        
        "04장-커넥션-관리": "/40967902-b9d0-ed9e-7abd-8eb094e6c226", 
        
        "05장-웹-서버": "/4757f83b-b230-ecd5-01f0-03a532907199", 
        
        "06장-프락시": "/b1fec897-d012-3803-4224-a1fac06a14c4", 
        
        "07장-캐시": "/56808a7e-abd1-979f-c7f9-fc2a81ce05ca", 
        
        "10장-http-2-0": "/a976befd-aad6-2cc0-f1bd-650205528f98", 
        
        "11장-클라이언트-식별과-쿠키": "/820b29f3-5dd3-ec36-ff7d-46b2e110a122", 
        
        "12장-기본-인증": "/66a1b5e5-9448-4476-c36b-1c1d8b77d079", 
        
        "14장-보안-http": "/e2f40fd5-9d83-5d33-3945-d93010f32ce0", 
        
        "01장-http-개관": "/1342bd24-dee7-d8f6-b63c-909e6e026b54", 
        
        "15장-엔터티와-인코딩": "/e4f6b6ab-b3f5-5b26-2ff7-5df8e3a303a0", 
        
        "16장-국제화": "/c7c60c25-9bf8-d3ea-3d0a-0cc7a44a96f1", 
        
        "17장-내용-협상과-트랜스코딩": "/e064e862-9f12-7734-dbbd-b18a7676aa6a", 
        
        "about": "/19dc863e-9942-eee3-ea3c-0b5f9245dcfb", 
        
        "github-action-에서-특정-label-이-붙은-pr-건너뛰기": "/0654680d-f102-7159-d06c-99f2e46aa34e", 
        
        "http-완벽-가이드": "/35d2bb9e-3cea-3de7-4405-27f2965e2716", 
        
        "identifiable": "/23541f6b-c82d-d953-2284-dde1ad84ec46", 
        
        "spm-패키지-dependency-설정하기": "/c7df7494-6ac2-77d5-5367-d34e3b260d71", 
        
        "safe-area-를-변경하려면": "/7cfc1bcf-a5a7-b153-4d67-19da5e04a55c", 
        
        "tabview-scrollview": "/a6f7c741-4d45-d56e-7c60-aea6037ccc1a", 
        
        "root": "/a2bc19f8-43a2-68d3-81ae-3d280c221d20", 
        
        "wiki": "/wiki/root-index/", 
        
        "thread-safety한-싱글톤": "/dcded7c6-5ce0-ebca-6536-e7323d041de4", 
        
        "외부-cocoapods-라이브러리-spm-으로-배포하기": "/1339c97d-6732-f545-94d4-6a7453b9e1b2", 
        
        "자식-뷰-컨트롤러에-이벤트가-전파되지-않음": "/641670cf-215e-936c-44df-1d00acf50e2f", 
        
        "하기-싫은-일은-작게-나누기": "/7c3093ec-e4ac-31f8-b22e-08c817377f1d"
        
    }
    </script>
        
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- 참고: https://jekyllrb.com/docs/liquid/filters/ -->
    <title>[Swift] Writing High Performance Swift Code - 🌩️ 먹구름</title>

    <meta name="description" content="">
    <meta name="google-site-verification" content="xD2UvBTOH6xxBi9MseahHz4Nt9u2vYZbgY2wVo7Bdyc" />

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://localhost:4000/34dea93e-05e9-9d47-f058-328b54789fd3">
    <link rel="alternate" type="application/rss+xml" title="🌩️ 먹구름" href="http://localhost:4000/feed.xml" />

    <meta property="og:type" content="website">
    <meta property="og:title" content="[Swift] Writing High Performance Swift Code">
    <meta property="og:description" content="">
    <meta property="og:image" content="http://localhost:4000/resource/johngrib.png">
    <meta property="og:url" content="http://localhost:4000/34dea93e-05e9-9d47-f058-328b54789fd3">

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:url" content="http://localhost:4000/34dea93e-05e9-9d47-f058-328b54789fd3" />
    <meta name="twitter:title" content="[Swift] Writing High Performance Swift Code" />
    <meta name="twitter:description" content="" />

    <link rel="apple-touch-icon" sizes="57x57"        href="/resource/icon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60"        href="/resource/icon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72"        href="/resource/icon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76"        href="/resource/icon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114"      href="/resource/icon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120"      href="/resource/icon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144"      href="/resource/icon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152"      href="/resource/icon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180"      href="/resource/icon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/resource/icon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32"   href="/resource/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96"   href="/resource/icon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16"   href="/resource/icon/favicon-16x16.png">
    <link rel="manifest" href="/resource/icon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/resource/icon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=SAMPLE-VALUE"></script>
    <script>
        // https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
        async function aesGcmDecrypt(ciphertext, password) {
            const pwUtf8 = new TextEncoder().encode(password);
            const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);
            const iv = ciphertext.slice(0,24).match(/.{2}/g).map(byte => parseInt(byte, 16));
            const alg = { name: 'AES-GCM', iv: new Uint8Array(iv) };
            const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']);
            const ctStr = atob(ciphertext.slice(24));
            const ctUint8 = new Uint8Array(ctStr.match(/[\s\S]/g).map(ch => ch.charCodeAt(0)));
            const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8);
            const plaintext = new TextDecoder().decode(plainBuffer);
            return plaintext;
        }
        async function aesGcmEncrypt(plaintext, password) {
            const pwUtf8 = new TextEncoder().encode(password);
            const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const alg = { name: 'AES-GCM', iv: iv };
            const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['encrypt']);
            const ptUint8 = new TextEncoder().encode(plaintext);
            const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUint8);
            const ctArray = Array.from(new Uint8Array(ctBuffer));
            const ctStr = ctArray.map(byte => String.fromCharCode(byte)).join('');
            const ctBase64 = btoa(ctStr);
            const ivHex = Array.from(iv).map(b => ('00' + b.toString(16)).slice(-2)).join('');
            return ivHex+ctBase64;
        }

        aesGcmDecrypt('THIS-IS-SAMPLE-VALUE', 'http://localhost:4000')
            .then(function(ua) {
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', ua);
                console.log('The gtag config has been finished.');
            })
            .catch(function(error) {
                console.log(error);
                console.log('The gtag id is invalid.');
            });
    </script>



</head>
<header class="header">
    <div>
        <a class="site-title emoji" href="/">🌩️ 먹구름</a>
    </div>
    <div class="site-title-right-container">
        <a class="site-title-right" href="/about/">
            <span class="emoji">👻</span>
            <span> about</span>
        </a>
        <a class="site-title-right" id="random-button">
            <span class="emoji">🎲</span>
            <span> random</span>
        </a>
        <a class="site-title-right" href="/wiki/root-index/">
            <span class="emoji">🗂️</span>
            <span> index</span>
        </a>
        <a class="site-title-right" href="/blog/">
            <span class="emoji">💾</span>
            <span> blog</span>
        </a>
        <a class="site-title-right" href="/tag/">
            <span class="emoji">🏷️</span>
            <span> tag</span>
        </a>
        <a class="site-title-right" href="/search">
            <span class="emoji">🔍</span>
            <span> search</span>
        </a>
    </div>
</header>
<script async src="/js/shortcut.js"></script>

    <body>
        <div class="page-content">
            <div class="post">
                
<input type="hidden" id="thisName" value="/Writing High Performance Swift Code"/>
<div class="post">
    <header class="post-header">
        <h1 class="page-title">
            <a href="/34dea93e-05e9-9d47-f058-328b54789fd3"> [Swift] Writing High Performance Swift Code </a>
        </h1>
    
        <div class="history-button">
            <p><a href="https://github.com/jwonylee/jwonylee.github.io/blame/master/_wiki//Writing High Performance Swift Code.md" target="_blank">created: 2022.05.12</a></p>
            <p><a href="https://github.com/jwonylee/jwonylee.github.io/blame/master/_wiki//Writing High Performance Swift Code.md" target="_blank">updated: </a></p>
            <p>
                <a href="https://github.com/jwonylee/jwonylee.github.io/edit/master/_wiki//Writing High Performance Swift Code.md">편집하기</a>
                /
                <a href="https://github.com/jwonylee/jwonylee.github.io/issues/new?title=%5BSwift%5D+Writing+High+Performance+Swift+Code&body=의견을%20남겨주세요">의견 남기기</a>
            </p>
        </div>

        <div id="parent-list"></div>



    <div class="post-tag">
    
</div>




    </header>
    <article class="post-content">
        <blockquote>
  <p><a href="https://github.com/apple/swift/blob/main/docs/OptimizationTips.rst#writing-high-performance-swift-code">Writing High-Performance Swift Code</a>를 읽고 정리했습니다.</p>
</blockquote>

<h2 id="enabling-optimizations">Enabling Optimizations</h2>

<p>스위프트는 세 가지 최적화 수준을 제공한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-Onone</code>: 최소한의 최적화를 수행하고 모든 디버그 정보를 보존한다.</li>
  <li><code class="language-plaintext highlighter-rouge">-O</code>: 대부분의 Product(실제 서비스)를 위한 것이다. 공격적인 최적화를 수행한다. 디버그 정보는 일부 손실된다.</li>
  <li><code class="language-plaintext highlighter-rouge">-Osize</code>: 컴파일러가 성능보다 코드 크기를 우선시하는 특수 최적화 모드이다.</li>
</ul>

<p>프로젝트 파일을 통해 설정할 수 있다.</p>

<h2 id="whole-module-optimizations-wmo">Whole Module Optimizations (WMO)</h2>

<p>기본적으로 스위프트는 각 파일을 개별적으로 컴파일한다. 이를 통해 Xcode는 여러 파일을 병렬로 매우 빠르게 컴파일 할 수 있다. 그러나, 각 파일을 별도로 컴파일하면 특정 컴파일러 최적화가 방지된다. 스위프트는 전체 프로그램을 하나의 파일인 것처럼 컴파일하고 프로그램을 단일 컴파일 단위인 것처럼 최적화 할 수 있다.</p>

<p>swiftc 명령줄 플래그 <code class="language-plaintext highlighter-rouge">-whole-module-optimization</code>를 사용하여 활성화 할 수 있다. 이 모드에서 컴파일된 프로그램은 컴파일하는 데 더 오래 걸릴 가능성이 높지만, 더 빨리 실행될 수 있다.</p>

<p>이 모드는 Xcode 빌드 설정 'Whole Module Optimizations`에서 활성화 할 수 있다.</p>

<h2 id="dynamic-dispatch-줄이기">Dynamic Dispatch 줄이기</h2>

<blockquote>
  <p>Dynamic Dispatch</p>

  <p>In computer science, dynamic dispatch is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time. It is commonly employed in, and considered a prime characteristic of, object-oriented programming (OOP) languages and systems.
컴퓨터 과학에서 Dynamic Dispatch는 런타임에 호출할 다형성 작업(메서드 또는 함수)의 구현을 선택하는 과정이다. 그것은 일반적으로 객체 지향 프로그래밍(OOP) 언어와 시스템의 주요 특성으로 여겨진다.</p>
</blockquote>

<p>Dynamic Dispatch 는 기본적으로 vtable 을 통해 간접 호출한다.</p>

<blockquote>
  <p>vtable</p>

  <p>vtable is a mechanism used in a programming language to support dynamic dispatch (or run-time method binding).
Dynamic Dispatch(또는 런타임 메소드 바인딩)를 지원하기 위해 프로그래밍 언어에서 사용되는 메커니즘이다.</p>
</blockquote>

<p>간접 호출 자체는 오버헤드 외에도 많은 컴파일러 최적화를 방지하기 때문에 직접 함수 호출하는 것보다 느리다.</p>

<h3 id="상속하지-않는-경우-final-키워드-사용하기">상속하지 않는 경우 <code class="language-plaintext highlighter-rouge">final</code> 키워드 사용하기</h3>

<p><code class="language-plaintext highlighter-rouge">final</code> 키워드를 사용하면 컴파일러가 직접 함수 호출을 할 수 있음을 의미한다.</p>

<h3 id="파일-외부에서-액세스할-필요가-없는-경우-private-fileprivate-사용하기">파일 외부에서 액세스할 필요가 없는 경우 <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">fileprivate</code> 사용하기</h3>

<p><code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">fileprivate</code>을 적용하면 선언된 파일에 대한 선언의 가시성이 제한된다. 이를 통해 컴파일러는 잠재적으로 재정의할 수 있는 다른 모든 선언을 확인할 수 있다. ??</p>

<p>컴파일러가 <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">fileprivate</code> 키워드를 통해 동일한 파일에 대한 상속.. 재선언이 없다고 가정 하고 <code class="language-plaintext highlighter-rouge">final</code> 키워드로 자동 유추 + 직접 호출한다.</p>

<h3 id="whole-module-optimization-이-활성화된-경우-모듈-외부에서-액세스할-필요가-없을-때-internal-키워드-사용">Whole Module Optimization 이 활성화된 경우, 모듈 외부에서 액세스할 필요가 없을 때 <code class="language-plaintext highlighter-rouge">internal</code> 키워드 사용</h3>

<p><code class="language-plaintext highlighter-rouge">WMO</code>는 컴파일러가 모듈의 소스를 한 번에 모두 컴파일하도록 한다. <code class="language-plaintext highlighter-rouge">internal</code>은 현재 모듈 외부에서 볼 수 없기 때문에 잠재적으로 재정의될 수 있는 모든 선언을 자동으로 검색하여 <code class="language-plaintext highlighter-rouge">final</code>로 유추한다.</p>

<p>*: Swift 는 기본 액세스 제어 수준이 <code class="language-plaintext highlighter-rouge">internal</code>이기 때문에 따로 선언하지 않았으면 자동으로 이득(?)을 얻을 수 있다.</p>

<h2 id="컨테이너-유형을-효율적으로-사용">컨테이너 유형을 효율적으로 사용</h2>

<p>*Container: Array, Dictionary, (maybe Set?)</p>

<h3 id="배열에서-값-타입-사용">배열에서 값 타입 사용</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Don't use a class here.</span>
<span class="kd">struct</span> <span class="kt">PhonebookEntry</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">a</span><span class="p">:</span> <span class="p">[</span><span class="kt">PhonebookEntry</span><span class="p">]</span>
</code></pre></div></div>

<p>큰 값 유형을 사용하는 것과 참조 유형을 사용하는 것 사이에는 trade-off 가 있음을 명심해야 한다. 어떤 경우에는 큰 값 유형을 복사하고 이동하는 오버헤드가 bridiging 과 retain/release 오버헤드를 제거하는 비용보다 크다.</p>

<p>생각) 값 유형이 너무 크면 그걸 복사하는 비용보다 참조 유형의 레퍼런스를 복사하는 것이 더 싸다는 뜻인듯?</p>

<h3 id="nsarray-브리징이-필요하지-않은-경우-참조-유형과-함께-contigousarray를-사용"><code class="language-plaintext highlighter-rouge">NSArray</code> 브리징이 필요하지 않은 경우 참조 유형과 함께 <code class="language-plaintext highlighter-rouge">ContigousArray</code>를 사용</h3>

<p><code class="language-plaintext highlighter-rouge">NSArray</code> 를 직접 사용해본 경험이 전무해서 어떤 때에 사용해야 할 지 아직까진 와닿지 않는다. 그래도 브리징이라는 개념을 알기 위해서 아래의 글들을 읽어보았는데, Objective-C 에서 타입 캐스팅을 브리징이라고 표현하는 것으로 파악했다.</p>

<ul>
  <li><a href="https://soooprmx.com/swift-array-05-nsarray/">(Swift) Array - 05. NSArray · Wireframe</a></li>
  <li><a href="https://babbab2.tistory.com/62">Objective-C) ARC와 Toll-Free Bridging</a></li>
</ul>

<h3 id="객체-재할당-대신-내부-변경을-사용한다">객체 재할당 대신 내부 변경을 사용한다.</h3>

<p>Swift의 모든 표준 라이브러리 컨테이너는 명시적 복사 대신 복사를 수행하기 위해 COW(copy-on-write)를 사용하는 값 유형이다. 많은 경우 컴파일러가 깊은 복사 대신 컨테이너를 유지하여 불필요한 복사본을 제거할 수 있다. 이는 컨테이너의 참조 횟수가 1보다 크고 컨테이너가 변경된 경우에만 기본 컨테이너를 복사하여 수행된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">c</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">var</span> <span class="nv">d</span> <span class="o">=</span> <span class="n">c</span> <span class="c1">// 여기에서 복사가 발생하지 않는다.</span>
<span class="n">d</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 여기에서 복사가 발생한다.</span>
</code></pre></div></div>

<p>때때로 COW 는 사용자가 주의하지 않으면 예상치 못한 추가 복사본을 도입할 수 있다. 이에 대한 예시는 함수에서 객체 재할당을 통해 mutation(변경) 를 수행하려고 시도하는 것이다. Swift 에서 모든 매개변수는 +1에서 전달된다. 즉 매개변수는 호출 시점 이전에 유지되고 호출 수신자의 끝에서 해제된다. 이것은 다음과 같은 함수를 작성하는 경우를 의미한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">append_one</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">a</span> <span class="o">=</span> <span class="nf">append_one</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>a may be copied despite the version of a without one appended to it has no uses after append_one due to the assignment. This can be avoided through the usage of inout parameters:</p>
</blockquote>

<p>할당으로 인해 <code class="language-plaintext highlighter-rouge">append_one</code> 이후에는 사용되지않는 버전이 추가되었음에도 불구하고 복사될 수 있다. 이것은 <code class="language-plaintext highlighter-rouge">inout</code> 매개변수를 사용하여 피할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">append_one_in_place</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nf">append_one_in_place</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="wrapping-operations-wrapping-작업">Wrapping operations (Wrapping 작업)</h2>

<p>Swift 는 일반 산술을 수행할 때 오버플로를 확인하여 정수 오버플로 버그를 제거한다. 오버플로가 발생할 수 없거나 작업을 래핑하도록 허용한 결과가 올바른 경우 이러한 검사는 고성능 코드에서 적절하지 않을 수 있다.</p>

<h3 id="오버플로가-발생할-수-없음을-증명할-수-있는-경우-wrapping-interger-산술을-사용한다">오버플로가 발생할 수 없음을 증명할 수 있는 경우 wrapping interger 산술을 사용한다.</h3>

<p>성능이 중요한 코드에서는 wrapping arithmetic 을 사용하여 안전하다는 것을 알고 있으면 오버플로 검사를 방지할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">a</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nv">b</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nv">c</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>

<span class="c1">// 전제 조건: 모든 a[i], b[i]: a[i] + b[i]가 오버플로 되지 않거나,</span>
<span class="c1">// 또는 래핑 결과가 필요하다.</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="n">n</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>&amp;+, &amp;-, &amp;* 연산자의 동작은 완전히 정의되어 있다. 결과는 오버플로가 발생할 경우 단순히 래핑된다. 따라서 Int.max &amp;+ 1은 Int.min으로 보장된다 (C에서 INT_MAX + 1이 정의되지 않은 동작임).</p>

<h2 id="제네릭">제네릭</h2>

<p>이 부분은 이해를 못했기 때문에 추가로 다시 공부할 예정이다.</p>

<blockquote>
  <p>When optimizations are enabled, the Swift compiler looks at each invocation of such code and attempts to ascertain the concrete (i.e. non-generic type) used in the invocation. If the generic function's definition is visible to the optimizer and the concrete type is known, the Swift compiler will emit a version of the generic function specialized to the specific type. This process, called specialization, enables the removal of the overhead associated with generics. Some more examples of generics:</p>
</blockquote>

<p>최적화가 활성화 되면, ~~~ 과정을 거쳐서 제네릭과 관련된 오버헤드를 제거할 수 있게 해준다. 에서 과정을 이해 못함.</p>

<h2 id="the-cost-of-large-swift-values">The cost of large Swift values</h2>

<p>Swift 에서 값은 데이터의 고유한 복사본을 유지한다. 값이 독립적인 상태를 갖도록 하는 것과 같이 값 유형을 사용하면 몇 가지 이점이 있다. 값을 복사할 때(할당, 초기화 및 인수 전달의 영향) 프로그램은 값의 새 복사본을 만든다. 일부 큰 값의 경우 이러한 복사본은 시간이 많이 걸리고 프로그램 성능을 저하시킬 수 있다.</p>

<p>"값" 노드를 사용하여 트리를 정의하는 아래의 예가 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{}</span>
<span class="kd">struct</span> <span class="kt">Node</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">P</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Tree</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">node</span><span class="p">:</span> <span class="kt">P</span><span class="p">?</span>
  <span class="nf">init</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>트리가 복사될 때(인수로 전달, 초기화 또는 할당) 전체 트리를 복사해야 한다. 우리 트리의 경우 이것은 malloc/free 에 대한 많은 호출과 상당한 참조 카운팅 오버헤드를 필요로 하는 값비싼 작업이다.</p>

<p>그러나, 값의 의미가 남아 있는 한 값이 메모리에 복사되는지 여부는 크게 신경쓰지 않는다.</p>

<h3 id="큰-값에-대해-copy-on-write-semantics-를-사용하라">큰 값에 대해 copy-on-write semantics 를 사용하라.</h3>

<p>큰 값을 복사하는 비용을 없애기 위해 cow 를 채택하라. cow를 구현하는 가장 쉬운 방법은 Array와 같은 cow 구조를 사용하는 것이다. Swift 배열은 값이지만, 배열의 내용은 배열의 내용은 copy on write 특성을 특징으로 하기 때문에 배열이 인수로 전달될 때마다 복사되지 않는다.</p>

<p>이 간단한 변경은 트리 데이터 구조의 성능에 큰 영향을 미치며, 배열을 인수로 전달하는 비용은 트리 크기에 따라 O(n)에서 O(1)로 떨어진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Tree</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">node</span><span class="p">:</span> <span class="p">[</span><span class="kt">P</span><span class="p">?]</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">thing</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 방식을 사용하면 두 가지 단점이 있다.</p>
<ol>
  <li>Array가 값 래퍼의 컨텍스트에서 의미가 없는 <code class="language-plaintext highlighter-rouge">append</code>, <code class="language-plaintext highlighter-rouge">count</code>와 같은 메서드를 노출한다는 것이다. 이러한 방법은 참조 래퍼를 사용하기 어렵게 만들 수 있다.</li>
  <li>Array에 프로그램 안정성과 Objective-C 와의 상호 작용을 보장하기 위한 코드가 있다는 것이다. Swift 는 인덱싱된 액세스가 배열 범위 내에서 속하는지 확인하고 배열 저장소를 확장해야 하는 경우 값을 저장할 때 확인한다. 이러한 런타임 검사는 속도를 늦출 수 있다.</li>
</ol>

<p>그래서 이것의 대안은 값 래퍼로 Array를 대체하기 위해 전용 copy-on-write 데이터 구조를 구현하는 것이다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">Ref</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">val</span><span class="p">:</span> <span class="kt">T</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">v</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span><span class="p">:</span> <span class="kt">Ref</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span> <span class="n">ref</span> <span class="o">=</span> <span class="kt">Ref</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>

    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ref</span><span class="o">.</span><span class="n">val</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
          <span class="k">if</span> <span class="o">!</span><span class="nf">isKnownUniquelyReferenced</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="kt">Ref</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span>
            <span class="k">return</span>
          <span class="p">}</span>
          <span class="n">ref</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">newValue</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Box</code> 타입은 위의 코드 샘플에서 배열을 대체할 수 있다.</p>

<h2 id="프로토콜">프로토콜</h2>

<h3 id="클래스에-의해서만-만족되는-프로토콜을-클래스-프로토콜로-표시하라">클래스에 의해서만 만족되는 프로토콜을 클래스 프로토콜로 표시하라.</h3>

<p>Swift는 프로토콜 채택을 클래스로만 제한할 수 있다. 프로토콜을 클래스 전용으로 표시하는 것의 한 가지 이점은 클래스만 프로토콜을 충족한다는 지식을 기반으로 컴파일러가 프로그램을 최적화할 수 있다는 것이다. 예를 들어, ARC 메모리 관리 시스템은 클래스를 다루고 있다는 것을 알고 있으면 쉽게 유지(객체의 참조 횟수 증가)할 수 있다. 이 지식이 없으면 컴파일러는 구조체가 프로토콜을 충족할 수 있다고 가정해야 하며 비용이 많이 들 수 있는 중요하지 않은 구조체를 유지하거나 해제할 준비가 필요하다.</p>

<p>프로토콜의 채택을 클래스로 제한하는 것이 합리적이라면 프로토콜을 클래스 전용 프로토콜로 표시하여 더 나은 런타임 성능을 얻을 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Pinable</span><span class="p">:</span> <span class="kt">AnyObject</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">ping</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="생각">생각</h2>

<p>쉽게 적용할 수 있는 부분은 네 가지 인 것 같다.</p>
<ul>
  <li>프로젝트 최적화 모드 설정하기</li>
  <li>상속하지 않는 경우 <code class="language-plaintext highlighter-rouge">final</code> 키워드 명시하기</li>
  <li>외부로 노출되지 않는 경우 <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">fileprivate</code> 명시하기</li>
  <li>클래스 프로토콜 표시하기</li>
</ul>

<p>최근에 회사 프로젝트도 코드 정리하면서 <code class="language-plaintext highlighter-rouge">final</code> 키워드부터 열심히 명시하고 있다. 프로퍼티/메서드 숨기기도 해야하는데, 이건 도무지 엄두가 안나네. 😩</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://github.com/apple/swift/blob/main/docs/OptimizationTips.rst#writing-high-performance-swift-code">Writing High-Performance Swift Code</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic dispatch - Wikipedia</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Virtual_method_table">Virtual method table - Wikipedia</a></li>
</ul>

<h2 id="태그">태그</h2>

<p>#Swift</p>

    </article>


    
    <div class="giscus"></div>
    <div class="post-comments">
    <script src="https://giscus.app/client.js"
        data-repo="jwonylee/jwonylee.github.io"
        data-repo-id="SAMPLE-VALUE"
        data-category="Announcements"
        data-category-id="SAMPLE-VALUE"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="ko"
        crossorigin="anonymous"
        data-mapping="specific"
        data-term=""
        data-strict="0"
        async>
    </script>
    </div>



</div>
<script async src="/js/create-link.js"></script>


<script async>
    ;(function() {
        const tableList = document.querySelectorAll('.table-generate');

        if (tableList == null) {
            return;
        }

        for (let i = 0; i < tableList.length; i++) {
            const ul = tableList[i];
            const draw = {
                th: '',
                td: ''
            };

            const rows = ul.children;
            for (let j = 0; j < rows.length; j++) {
                const row = rows[j].children[0];
                const columns = row.children;
                const isHeader = /^th/.test(rows[j].innerHTML);
                const colTag = isHeader ? 'th' : 'td';

                let colData = '';
                for (let k = 0; k < columns.length; k++) {
                    const column = columns[k];
                    const content = column.innerHTML;
                    colData += `<${colTag}>${content}</${colTag}>`;
                }

                const trHtml = `<tr>${colData}</tr>`

                draw[colTag] += trHtml;
            }

            const result = `
                <table>
                    <thead>${draw.th}</thead>
                    <tbody>${draw.td}</tbody>
                </table>`

            const targetId = ul.getAttribute('data-target-id');
            document.getElementById(targetId).innerHTML = result;
            ul.remove();
        }
    })();
    ;(function() {
        const source = document.querySelectorAll('.dynamic-insert');

        if (source == null) {
            return;
        }

        for (let i = 0; i < source.length; i++) {
            const item = source[i];

            const target = item.getAttribute('data-target-selector');
            document.querySelector(target).innerHTML = item.outerHTML;
            item.remove();
        }
    })();
</script>


<script async src="/js/parent.js"></script>
<script async src="/js/toc-highlight.js"></script>

            </div>
        </div>
        <footer class="footer">
    <div>

    </div>

    <script data-ad-client="SAMPLE-VALUE" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</footer>
    </body>
</html>
