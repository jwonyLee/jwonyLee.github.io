<h2 id="기록">기록</h2>

<p><code class="language-plaintext highlighter-rouge">RxSwift</code>는 관찰 가능한 스트림을 이용한 비동기 프로그래밍 API</p>

<p>하나 또는 연속된 항목이 들어온다. 연속된 값을 일부 제한해서 사용해야 한다면? <code class="language-plaintext highlighter-rouge">throttle</code> 또는 <code class="language-plaintext highlighter-rouge">debounce</code>를 사용한다.</p>

<h3 id="throttle-페이지네이션-구현">throttle: 페이지네이션 구현</h3>

<p>테이블 뷰나 컬렉션 뷰를 이용해서 데이터를 표시할 때, 페이지네이션을 구현하게 된다. 이 때, 화면 끝에 도달하면 다음 데이터를 표시하기 위해 API를 호출한다.</p>

<p>테이블 뷰나 컬렉션 뷰를 이용해 데이터를 표시하고, 페이지네이션을 구현한다면 다음과 같은 방식으로 작동한다.</p>

<ol>
  <li>초기 데이터를 표시한다.</li>
  <li>스크롤이 끝에 도달했는 지 감지한다.</li>
  <li>다음 데이터를 표시하기 위한 API를 호출한다.</li>
  <li>가져온 데이터를 화면에 표시한다.</li>
  <li>2~4의 과정을 반복한다.</li>
</ol>

<p>이것을 RxSwift로 해결한다면 이렇게 만들 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">contentOffset</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="n">contentSize</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="k">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>

<p>이 코드의 문제는, 스크롤은 연속적으로 동작하기 때문에 여러 번 불필요한 API 호출을 하게 된다. 불필요한 호출을 방지하기 위해서 특정 시간동안 여러 번 호출이 들어오면 한 번만 동작하게 해주는 연산자가 있다. 그게 바로 <code class="language-plaintext highlighter-rouge">throttle</code></p>

<p>그래서 위의 코드에 <code class="language-plaintext highlighter-rouge">throttle</code>을 추가해주면 다음과 같다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tableView</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">contentOffset</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="n">contentSize</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="k">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">throttle</span><span class="p">(</span><span class="o">.</span><span class="nf">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="nv">latest</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="kt">MainScheduler</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>

<p>첫 번째 인자로 들어가는 값은 제한 시간이다. 이벤트가 방출되면 제한 시간동안 이벤트가 더 방출되지 않는다.
두 번째 인자로 들어가는 값은 <code class="language-plaintext highlighter-rouge">true</code>로 주면, 첫번째 + 마지막 이벤트를 실행한다. <code class="language-plaintext highlighter-rouge">false</code>로 주면, 마지막 이벤트만 넘긴다.</p>

<h3 id="debounce-자동-완성-검색">debounce: 자동 완성 검색</h3>

<p>그렇다면 <code class="language-plaintext highlighter-rouge">debounce</code>는 언제 사용할까? <code class="language-plaintext highlighter-rouge">debounce</code>는 특정 시간마다 그 시점에 존재하는 항목을 배출한다. 그래서 나는 0.5초마다 텍스트 필드에 있는 텍스트를 검색하는 로직을 작성할 때 사용했다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">searchBar</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">orEmpty</span>
    <span class="o">.</span><span class="nf">debounce</span><span class="p">(</span><span class="o">.</span><span class="nf">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="kt">MainScheduler</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">distinctUntilChanged</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">keywordRelay</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>

<p>더불어 <code class="language-plaintext highlighter-rouge">distinctUntilChanged()</code>를 사용해서 중복 값은 배출하지 않도록 작성했다.</p>

<h2 id="생각">생각</h2>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://kkimin.tistory.com/43?category=955083">Rxswift Debounce / Throttle :: kkimin's swift</a></li>
</ul>

<h2 id="태그">태그</h2>

<p>#iOS/RxSwift</p>
